{"version":3,"file":"index.umd.js","sources":["../src/misc/arrayHelpers.ts","../src/misc/logger.ts","../src/misc/pathHelper.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/providers/database/ResourceManager.ts","../src/providers/database/FirebaseClient.ts","../src/providers/DataProvider.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/AuthProvider.ts"],"sourcesContent":["function isEmptyObj(obj) {\n  if (!obj) {\n    return true;\n  }\n  return JSON.stringify(obj) === \"{}\";\n}\n\nexport function sortArray(\n  data: Array<{}>,\n  field: string,\n  dir: \"asc\" | \"desc\"\n): void {\n  data.sort((a: {}, b: {}) => {\n    const rawA = a[field];\n    const rawB = b[field];\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\n    let aValue: string, bValue: string;\n    if (isNumberField) {\n      aValue = rawA;\n      bValue = rawB;\n    } else {\n      aValue = (a[field] || \"\").toString().toLowerCase();\n      bValue = (b[field] || \"\").toString().toLowerCase();\n    }\n    if (aValue > bValue) {\n      return dir === \"asc\" ? 1 : -1;\n    }\n    if (aValue < bValue) {\n      return dir === \"asc\" ? -1 : 1;\n    }\n    return 0;\n  });\n}\n\nexport function filterArray(\n  data: Array<{}>,\n  searchFields: { [field: string]: string }\n): Array<{}> {\n  if (isEmptyObj(searchFields)) {\n    return data;\n  }\n  const searchObjs = Object.keys(searchFields).map(n => ({\n    name: n,\n    value: (searchFields[n] || '').toLowerCase()\n  }));\n  return data.filter(row =>\n    searchObjs.reduce(\n      (prev, curr) => doesRowMatch(row, curr.name, curr.value) && prev,\n      true\n    )\n  );\n}\n\nfunction doesRowMatch(\n  row: {},\n  searchField: string,\n  searchValue: string\n): boolean {\n  const searchPart = row[searchField];\n  if (typeof searchPart !== \"string\") {\n    return false;\n  }\n  return searchPart\n    .toString()\n    .toLowerCase()\n    .includes(searchValue.toLowerCase());\n}\n","import { RAFirebaseOptions } from \"providers/RAFirebaseOptions\";\n\n// UTILS\n\nexport class SimpleLogger {\n  private title = \"ðŸ”¥r-a-f: \";\n\n  isEnabled() {\n    return !!localStorage.getItem('LOGGING_ENABLED');\n  }\n\n  public get log() {\n    if (!this.isEnabled()) {\n      return (...any) => {};\n    }\n    const boundLogFn: (...any) => void = console.log.bind(console, this.title);\n    return boundLogFn;\n  }\n\n  public get warn() {\n    if (!this.isEnabled()) {\n      return (...any) => {};\n    }\n    const boundLogFn: (...any) => void = console.warn.bind(console, this.title);\n    return boundLogFn;\n  }\n\n  public get error() {\n    if (!this.isEnabled()) {\n      return (...any) => {};\n    }\n    const boundLogFn: (...any) => void = console.error.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n}\n\nconst logger = new SimpleLogger();\n\nexport function CheckLogging(config: {}, options: RAFirebaseOptions) {\n  const logSignalDeprecated = config && config[\"debug\"];\n  const logSignal = options.logging;\n  if (logSignalDeprecated || logSignal) {\n    localStorage.setItem('LOGGING_ENABLED', 'true')\n  } else {\n    localStorage.removeItem('LOGGING_ENABLED')\n  }\n}\n\nexport const log = logger.log;\nexport const logWarn = logger.warn;\nexport const logError = logger.error;\n","import path from 'path-browserify'\n\nexport function getAbsolutePath(rootRef: string, relativePath: string): string {\n  if (!rootRef) {\n    return relativePath;\n  }\n  if (!relativePath) {\n    throw new Error('Resource name must be a string of length greater than 0 characters');\n  }\n  const withSlashes = path.join('/', rootRef, '/', relativePath, '/');\n  const slashCount = withSlashes.split(\"/\").length - 1\n  if (slashCount % 2) {\n    throw new Error(`The rootRef path must point to a \"document\" not a \"collection\"\ne.g. /collection/document/ or /collection/document/collection/document/`);\n  }\n  const withOutSlashes = withSlashes.slice(1, -1);\n  return withOutSlashes;\n}\n\nexport function joinPaths(path1, path2) {\n  return path.join(path1, path2);\n}","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && !check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","// Firebase types\nimport {\n  CollectionReference,\n  QueryDocumentSnapshot,\n  FirebaseFirestore\n} from \"@firebase/firestore-types\";\nimport { RAFirebaseOptions } from \"../RAFirebaseOptions\";\nimport { IFirebaseWrapper } from \"./firebase/IFirebaseWrapper\";\nimport { User } from \"@firebase/auth-types\";\nimport { log, getAbsolutePath, messageTypes, logError } from \"../../misc\";\n\nexport interface IResource {\n  path: string;\n  pathAbsolute: string;\n  collection: CollectionReference;\n  list: Array<{}>;\n}\n\nexport class ResourceManager {\n  private resources: {\n    [resourceName: string]: IResource;\n  } = {};\n\n  private db: FirebaseFirestore;\n\n  constructor(\n    private fireWrapper: IFirebaseWrapper,\n    private options: RAFirebaseOptions\n  ) {\n    this.db = fireWrapper.db();\n  }\n\n  public GetResource(relativePath: string): IResource {\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async TryGetResourcePromise(\n    relativePath: string,\n    collectionQuery: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    log(\"resourceManager.TryGetResourcePromise\", {\n      relativePath,\n      collectionQuery\n    });\n    await this.initPath(relativePath, collectionQuery);\n\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async RefreshResource(\n    relativePath: string,\n    collectionQuery: messageTypes.CollectionQueryType\n  ) {\n    log(\"resourceManager.RefreshResource\", { relativePath, collectionQuery });\n    await this.initPath(relativePath, collectionQuery);\n    const resource = this.resources[relativePath];\n\n    const collection = resource.collection;\n    const query = this.applyQuery(collection, collectionQuery);\n    const newDocs = await query.get();\n\n    resource.list = newDocs.docs.map(doc => this.parseFireStoreDocument(doc));\n    log(\"resourceManager.RefreshResource\", {\n      newDocs,\n      resource,\n      collectionPath: collection.path\n    });\n  }\n\n  public async GetSingleDoc(relativePath: string, docId: string) {\n    await this.initPath(relativePath);\n    const resource = this.resources[relativePath];\n    const docSnap = await resource.collection.doc(docId).get();\n    if (!docSnap.exists) {\n      throw new Error(\"react-admin-firebase: No id found matching: \" + docId);\n    }\n    const result = this.parseFireStoreDocument(docSnap);\n    log(\"resourceManager.GetSingleDoc\", {\n      relativePath,\n      resource,\n      docId,\n      docSnap,\n      result\n    });\n    return result;\n  }\n\n  private async initPath(\n    relativePath: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<void> {\n    const absolutePath = getAbsolutePath(this.options.rootRef, relativePath);\n    const isAccessible = await this.isCollectionAccessible(\n      absolutePath,\n      collectionQuery\n    );\n\n    const hasBeenInited = !!this.resources[relativePath];\n    log(\"resourceManager.initPath()\", {\n      absolutePath,\n      isAccessible,\n      hasBeenInited\n    });\n    if (!isAccessible && hasBeenInited) {\n      log(\"resourceManager.initPath() not accessible, removing resource...\");\n      this.removeResource(relativePath);\n      return;\n    }\n    if (hasBeenInited) {\n      log(\"resourceManager.initPath() has been initialized already...\");\n      return;\n    }\n    const collection = this.db.collection(absolutePath);\n    const list: Array<{}> = [];\n    const resource: IResource = {\n      collection: collection,\n      list: list,\n      path: relativePath,\n      pathAbsolute: absolutePath\n    };\n    this.resources[relativePath] = resource;\n    log(\"resourceManager.initPath() setting resource...\", {\n      resource,\n      allResources: this.resources,\n      collection: collection,\n      collectionPath: collection.path\n    });\n  }\n\n  private parseFireStoreDocument(doc: QueryDocumentSnapshot): {} {\n    const data = doc.data();\n    Object.keys(data).forEach(key => {\n      const value = data[key];\n      if (value && value.toDate && value.toDate instanceof Function) {\n        data[key] = value.toDate();\n      }\n    });\n    // React Admin requires an id field on every document,\n    // So we can just using the firestore document id\n    return { id: doc.id, ...data };\n  }\n\n  public async getUserLogin(): Promise<User> {\n    return new Promise((resolve, reject) => {\n      this.fireWrapper.auth().onAuthStateChanged(user => {\n        resolve(user);\n      });\n    });\n  }\n\n  private async isCollectionAccessible(\n    absolutePath: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<boolean> {\n    try {\n      const collection = this.db.collection(absolutePath);\n      const query = this.applyQuery(collection, collectionQuery);\n\n      await query.limit(1).get();\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  private removeResource(resourceName: string) {\n    delete this.resources[resourceName];\n  }\n\n  private applyQuery(\n    collection: CollectionReference,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): CollectionReference {\n    let collref: CollectionReference;\n    if (collectionQuery) {\n      collref = collectionQuery(collection);\n    } else {\n      collref = collection;\n    }\n    log(\"resourceManager.applyQuery() ...\", {\n      collection,\n      collectionQuery: (collectionQuery || \"-\").toString(),\n      collref\n    });\n    return collref;\n  }\n}\n","import { FirebaseFirestore } from \"@firebase/firestore-types\";\nimport { ResourceManager, IResource } from \"./ResourceManager\";\nimport { RAFirebaseOptions } from \"../RAFirebaseOptions\";\nimport { IFirebaseWrapper } from \"./firebase/IFirebaseWrapper\";\nimport { IFirebaseClient } from \"./IFirebaseClient\";\nimport {\n  filterArray,\n  joinPaths,\n  log,\n  logError,\n  messageTypes,\n  sortArray\n} from \"../../misc\";\n\nexport class FirebaseClient implements IFirebaseClient {\n  private db: FirebaseFirestore;\n  private rm: ResourceManager;\n\n  constructor(\n    private fireWrapper: IFirebaseWrapper,\n    private options: RAFirebaseOptions\n  ) {\n    this.db = fireWrapper.db();\n    this.rm = new ResourceManager(this.fireWrapper, this.options);\n  }\n  public async apiGetList(\n    resourceName: string,\n    params: messageTypes.IParamsGetList\n  ): Promise<messageTypes.IResponseGetList> {\n    log(\"apiGetList\", { resourceName, params });\n\n    const collectionQuery = params.filter.collectionQuery;\n    delete params.filter.collectionQuery;\n\n    const r = await this.tryGetResource(\n      resourceName,\n      \"REFRESH\",\n      collectionQuery\n    );\n    const data = r.list;\n    if (params.sort != null) {\n      const { field, order } = params.sort;\n      if (order === \"ASC\") {\n        sortArray(data, field, \"asc\");\n      } else {\n        sortArray(data, field, \"desc\");\n      }\n    }\n    // @ts-ignore\n    const filteredData = filterArray(data, params.filter);\n    const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n    const pageEnd = pageStart + params.pagination.perPage;\n    const dataPage = filteredData.slice(pageStart, pageEnd);\n    const total = filteredData.length;\n    return {\n      data: dataPage,\n      total\n    };\n  }\n  public async apiGetOne(\n    resourceName: string,\n    params: messageTypes.IParamsGetOne\n  ): Promise<messageTypes.IResponseGetOne> {\n    log(\"apiGetOne\", { resourceName, params });\n    try {\n      const data = await this.rm.GetSingleDoc(resourceName, params.id);\n      return { data: data };\n    } catch (error) {\n      throw new Error(\n        \"Error getting id: \" + params.id + \" from collection: \" + resourceName\n      );\n    }\n  }\n  public async apiCreate(\n    resourceName: string,\n    params: messageTypes.IParamsCreate\n  ): Promise<messageTypes.IResponseCreate> {\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiCreate\", { resourceName, resource: r, params });\n    const hasOverridenDocId = params.data && params.data.id;\n    log(\"apiCreate\", { hasOverridenDocId });\n    if (hasOverridenDocId) {\n      const overridenId = params.data.id;\n      const exists = (await r.collection.doc(overridenId).get()).exists;\n      if (exists) {\n        throw new Error(\n          `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\n        );\n      }\n      const data = await this.parseDataAndUpload(r, overridenId, params.data);\n      if (!overridenId) {\n        throw new Error(\"id must be a valid string\");\n      }\n      const docObj = { ...data };\n      this.checkRemoveIdField(docObj);\n      await this.addCreatedByFields(docObj);\n      await this.addUpdatedByFields(docObj);\n      log(\"apiCreate\", { docObj });\n      await r.collection.doc(overridenId).set(docObj, { merge: false });\n      return {\n        data: {\n          ...data,\n          id: overridenId\n        }\n      };\n    }\n    const newId = this.db.collection(\"collections\").doc().id;\n    const data = await this.parseDataAndUpload(r, newId, params.data);\n    const docObj = { ...data };\n    this.checkRemoveIdField(docObj);\n    await this.addCreatedByFields(docObj);\n    await this.addUpdatedByFields(docObj);\n    await r.collection.doc(newId).set(docObj, { merge: false });\n    return {\n      data: {\n        ...data,\n        id: newId\n      }\n    };\n  }\n  public async apiUpdate(\n    resourceName: string,\n    params: messageTypes.IParamsUpdate\n  ): Promise<messageTypes.IResponseUpdate> {\n    const id = params.id;\n    delete params.data.id;\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiUpdate\", { resourceName, resource: r, params });\n    const data = await this.parseDataAndUpload(r, id, params.data);\n    const docObj = { ...data };\n    this.checkRemoveIdField(docObj);\n    await this.addUpdatedByFields(docObj);\n    r.collection\n      .doc(id)\n      .update(docObj)\n      .catch(error => {\n        logError(\"apiUpdate error\", { error });\n      });\n    return {\n      data: {\n        ...data,\n        id: id\n      }\n    };\n  }\n  public async apiUpdateMany(\n    resourceName: string,\n    params: messageTypes.IParamsUpdateMany\n  ): Promise<messageTypes.IResponseUpdateMany> {\n    delete params.data.id;\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiUpdateMany\", { resourceName, resource: r, params });\n    const ids = params.ids;\n    const returnData = await Promise.all(\n      ids.map(async id => {\n        const data = await this.parseDataAndUpload(r, id, params.data);\n        const docObj = { ...data };\n        this.checkRemoveIdField(docObj);\n        await this.addUpdatedByFields(docObj);\n        r.collection\n          .doc(id)\n          .update(docObj)\n          .catch(error => {\n            logError(\"apiUpdateMany error\", { error });\n          });\n        return {\n          ...data,\n          id: id\n        };\n      })\n    );\n    return {\n      data: returnData\n    };\n  }\n  public async apiDelete(\n    resourceName: string,\n    params: messageTypes.IParamsDelete\n  ): Promise<messageTypes.IResponseDelete> {\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiDelete\", { resourceName, resource: r, params });\n    r.collection\n      .doc(params.id)\n      .delete()\n      .catch(error => {\n        logError(\"apiDelete error\", { error });\n      });\n    return {\n      data: params.previousData\n    };\n  }\n  public async apiDeleteMany(\n    resourceName: string,\n    params: messageTypes.IParamsDeleteMany\n  ): Promise<messageTypes.IResponseDeleteMany> {\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiDeleteMany\", { resourceName, resource: r, params });\n    const returnData: { id: string }[] = [];\n    const batch = this.db.batch();\n    for (const id of params.ids) {\n      batch.delete(r.collection.doc(id));\n      returnData.push({ id });\n    }\n    batch.commit().catch(error => {\n      logError(\"apiDeleteMany error\", { error });\n    });\n    return { data: returnData };\n  }\n  public async apiGetMany(\n    resourceName: string,\n    params: messageTypes.IParamsGetMany\n  ): Promise<messageTypes.IResponseGetMany> {\n    const r = await this.tryGetResource(resourceName, \"REFRESH\");\n    log(\"apiGetMany\", { resourceName, resource: r, params });\n    const ids = params.ids;\n    const matchDocSnaps = await Promise.all(\n      ids.map(id => r.collection.doc(id).get())\n    );\n    const matches = matchDocSnaps.map(snap => {\n      return { ...snap.data(), id: snap.id };\n    });\n    return {\n      data: matches\n    };\n  }\n  public async apiGetManyReference(\n    resourceName: string,\n    params: messageTypes.IParamsGetManyReference\n  ): Promise<messageTypes.IResponseGetManyReference> {\n    const r = await this.tryGetResource(resourceName, \"REFRESH\");\n    log(\"apiGetManyReference\", { resourceName, resource: r, params });\n    const data = r.list;\n    const targetField = params.target;\n    const targetValue = params.id;\n    const matches = data.filter(val => val[targetField] === targetValue);\n    if (params.sort != null) {\n      const { field, order } = params.sort;\n      if (order === \"ASC\") {\n        sortArray(matches, field, \"asc\");\n      } else {\n        sortArray(matches, field, \"desc\");\n      }\n    }\n    const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n    const pageEnd = pageStart + params.pagination.perPage;\n    const dataPage = matches.slice(pageStart, pageEnd);\n    const total = matches.length;\n    return { data: dataPage, total };\n  }\n  private async tryGetResource(\n    resourceName: string,\n    refresh?: \"REFRESH\",\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    if (refresh) {\n      await this.rm.RefreshResource(resourceName, collectionQuery);\n    }\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n  private async getCurrentUserEmail() {\n    const user = await this.rm.getUserLogin();\n    if (user) {\n      return user.email;\n    } else {\n      return \"annonymous user\";\n    }\n  }\n  private async getCurrentUserId() {\n    const user = await this.rm.getUserLogin();\n    if (user) {\n      return user.uid;\n    } else {\n      return \"annonymous user\";\n    }\n  }\n\n  private async parseDataAndUpload(r: IResource, id: string, data: any) {\n    if (!data) {\n      return data;\n    }\n    const docPath = r.collection.doc(id).path;\n\n    await Promise.all(\n      Object.keys(data).map(async fieldName => {\n        const val = data[fieldName];\n        const isArray = Array.isArray(val);\n        if (isArray) {\n          await Promise.all(\n            (val as []).map((arrayObj, index) => {\n              if (!!val[index] && val[index].hasOwnProperty(\"rawFile\")) {\n                return Promise.all([\n                  this.parseDataField(val[index], docPath, fieldName + index)\n                ]);\n              } else {\n                return Promise.all(\n                  Object.keys(arrayObj).map(arrayObjFieldName => {\n                    const arrayObjVal = arrayObj[arrayObjFieldName];\n                    return this.parseDataField(\n                      arrayObjVal,\n                      docPath,\n                      fieldName + arrayObjFieldName + index\n                    );\n                  })\n                );\n              }\n            })\n          );\n        }\n        await this.parseDataField(val, docPath, fieldName);\n      })\n    );\n    return data;\n  }\n\n  private checkRemoveIdField(obj: any) {\n    if (this.options.dontAddIdFieldToDoc) {\n      delete obj.id\n    }\n  }\n\n  private async addCreatedByFields(obj: any) {\n    if (this.options.disableMeta) {\n      return;\n    }\n    const currentUserIdentifier = this.options.associateUsersById ? await this.getCurrentUserId() : await this.getCurrentUserEmail();\n    obj.createdate = this.fireWrapper.serverTimestamp();\n    obj.createdby = currentUserIdentifier;\n  }\n\n  private async addUpdatedByFields(obj: any) {\n    if (this.options.disableMeta) {\n      return;\n    }\n    const currentUserIdentifier = this.options.associateUsersById ? await this.getCurrentUserId() : await this.getCurrentUserEmail();\n    obj.lastupdate = this.fireWrapper.serverTimestamp();\n    obj.updatedby = currentUserIdentifier;\n  }\n\n  private async parseDataField(ref: any, docPath: string, fieldPath: string) {\n    const hasRawFile = !!ref && ref.hasOwnProperty(\"rawFile\");\n    if (!hasRawFile) {\n      return;\n    }\n    ref.src = await this.uploadAndGetLink(ref.rawFile, docPath, fieldPath);\n    delete ref.rawFile;\n  }\n\n  private async uploadAndGetLink(\n    rawFile: any,\n    docPath: string,\n    fieldPath: string\n  ): Promise<string> {\n    const storagePath = joinPaths(docPath, fieldPath);\n    const storageLink = await this.saveFile(storagePath, rawFile);\n    return storageLink;\n  }\n\n  private async saveFile(storagePath: string, rawFile: any): Promise<string> {\n    log(\"saveFile() saving file...\", { storagePath, rawFile });\n    const task = this.fireWrapper\n      .storage()\n      .ref(storagePath)\n      .put(rawFile);\n    try {\n      const taskResult: firebase.storage.UploadTaskSnapshot = await new Promise(\n        (res, rej) => task.then(res).catch(rej)\n      );\n      const getDownloadURL = await taskResult.ref.getDownloadURL();\n      log(\"saveFile() saved file\", {\n        storagePath,\n        taskResult,\n        getDownloadURL\n      });\n      return getDownloadURL;\n    } catch (storageError) {\n      if (storageError.code === \"storage/unknown\") {\n        logError(\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\n          { storageError }\n        );\n      } else {\n        logError(\"saveFile() error saving file\", {\n          storageError\n        });\n      }\n    }\n  }\n}\n","import {\n  CREATE,\n  DELETE,\n  DELETE_MANY,\n  GET_LIST,\n  GET_MANY,\n  GET_MANY_REFERENCE,\n  GET_ONE,\n  UPDATE,\n  UPDATE_MANY\n} from \"react-admin\";\nimport { getAbsolutePath, log, CheckLogging } from \"../misc\";\nimport { RAFirebaseOptions } from \"./RAFirebaseOptions\";\nimport { FirebaseClient } from \"./database/FirebaseClient\";\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\n\nexport let fb: FirebaseClient;\n\nexport function DataProvider(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\n  const options = optionsInput || {};\n  VerifyDataProviderArgs(firebaseConfig, options);\n  CheckLogging(firebaseConfig, options);\n\n  log(\"react-admin-firebase:: Creating FirebaseDataProvider\", { firebaseConfig, options });\n  const fireWrapper = new FirebaseWrapper();\n  fireWrapper.init(firebaseConfig, optionsInput);\n  fb = new FirebaseClient(fireWrapper, options);\n  async function providerApi(type: string, resourceName: string, params: any): Promise<any> {\n    log(\"FirebaseDataProvider: event\", { type, resourceName, params });\n    switch (type) {\n      case GET_MANY:\n        return fb.apiGetMany(resourceName, params);\n      case GET_MANY_REFERENCE:\n        return fb.apiGetManyReference(resourceName, params);\n      case GET_LIST:\n        return fb.apiGetList(resourceName, params);\n      case GET_ONE:\n        return fb.apiGetOne(resourceName, params);\n      case CREATE:\n        return fb.apiCreate(resourceName, params);\n      case UPDATE:\n        return fb.apiUpdate(resourceName, params);\n      case UPDATE_MANY:\n        return fb.apiUpdateMany(resourceName, params);\n      case DELETE:\n        return fb.apiDelete(resourceName, params);\n      case DELETE_MANY:\n        return fb.apiDeleteMany(resourceName, params);\n      default:\n        return {};\n    }\n  }\n  return providerApi;\n}\n\nfunction VerifyDataProviderArgs(firebaseConfig: {}, options?: RAFirebaseOptions) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      \"Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider\"\n    );\n  }\n  if (options.rootRef) {\n    // Will throw error if rootRef doesn't point to a document\n    getAbsolutePath(options.rootRef, 'test');\n  }\n}","import { IFirebaseWrapper } from \"./IFirebaseWrapper\";\nimport { RAFirebaseOptions } from \"providers/RAFirebaseOptions\";\n\nimport firebase from \"firebase/app\";\nimport \"firebase/firestore\";\nimport \"firebase/auth\";\nimport \"firebase/storage\";\n\nexport class FirebaseWrapper implements IFirebaseWrapper {\n  private firestore: firebase.firestore.Firestore;\n  private app: firebase.app.App;\n\n  constructor() { }\n\n  public init(firebaseConfig: {}, options: RAFirebaseOptions): void {\n    this.app = ObtainFirebaseApp(firebaseConfig, options);\n    this.firestore = this.app.firestore();\n  }\n  public db(): firebase.firestore.Firestore {\n    return this.firestore;\n  }\n  public serverTimestamp() {\n    // This line doesn't work for some reason, might be firebase sdk.\n    // return firebase.firestore.FieldValue.serverTimestamp();\n    return new Date();\n  }\n  public auth() {\n    return this.app.auth() as any;\n  }\n  public storage() {\n    return this.app.storage();\n  }\n}\n\nfunction ObtainFirebaseApp(firebaseConfig: {}, options: RAFirebaseOptions): firebase.app.App {\n  if (options.app) {\n    return options.app;\n  }\n  const isInitialized = !!firebase.apps.length;\n  if (isInitialized) {\n    const app = firebase.app();\n    return app;\n  } else {\n    const app = firebase.initializeApp(firebaseConfig);\n    return app;\n  }\n}","import firebase from \"firebase/app\";\nimport \"firebase/auth\";\nimport { FirebaseAuth } from \"@firebase/auth-types\";\nimport { log, CheckLogging } from \"../misc\";\nimport { RAFirebaseOptions } from \"./RAFirebaseOptions\";\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\n\nclass AuthClient {\n  private auth: FirebaseAuth;\n\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\n    const options = optionsInput || {};\n    log(\"Auth Client: initializing...\", { firebaseConfig, options });\n    const fireWrapper = new FirebaseWrapper();\n    fireWrapper.init(firebaseConfig, options);\n    this.auth = fireWrapper.auth();\n    this.setPersistence(options.persistence);\n  }\n\n  setPersistence(persistenceInput: \"session\" | \"local\" | \"none\") {\n    let persistenceResolved: string;\n    switch (persistenceInput) {\n      case \"local\":\n        persistenceResolved = firebase.auth.Auth.Persistence.LOCAL;\n        break;\n      case \"none\":\n        persistenceResolved = firebase.auth.Auth.Persistence.NONE;\n        break;\n      case \"session\":\n      default:\n        persistenceResolved = firebase.auth.Auth.Persistence.SESSION;\n        break;\n    }\n    log(\"setPersistence\", { persistenceInput, persistenceResolved });\n    this.auth\n      .setPersistence(persistenceResolved)\n      .catch(error => console.error(error));\n  }\n\n  public async HandleAuthLogin(params) {\n    const { username, password } = params;\n\n    if (username && password) {\n      try {\n        const user = await this.auth.signInWithEmailAndPassword(\n          username,\n          password\n        );\n        log(\"HandleAuthLogin: user sucessfully logged in\", { user });\n        return user;\n      } catch (e) {\n        log(\"HandleAuthLogin: invalid credentials\", { params });\n        throw new Error(\"Login error: invalid credentials\");\n      }\n    } else {\n      return this.getUserLogin();\n    }\n  }\n\n  public HandleAuthLogout() {\n    return this.auth.signOut();\n  }\n\n  public HandleAuthError(error) {\n    log(\"HandleAuthLogin: invalid credentials\", { error });\n    return Promise.reject(\"Login error: invalid credentials\");\n  }\n\n  public HandleAuthCheck() {\n    return this.getUserLogin();\n  }\n\n  public getUserLogin() {\n    return new Promise((resolve, reject) => {\n      if (this.auth.currentUser) return resolve(this.auth.currentUser);\n      const unsubscribe = this.auth.onAuthStateChanged(user => {\n        unsubscribe();\n        if (user) {\n          resolve(user);\n        } else {\n          reject();\n        }\n      });\n    });\n  }\n\n  public async HandleGetPermissions() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.claims;\n    } catch (e) {\n      log(\"HandleGetPermission: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetJWTAuthTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.authTime;\n    } catch (e) {\n      log(\"HandleGetJWTAuthTime: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetJWTExpirationTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.expirationTime;\n    } catch (e) {\n      log(\"HandleGetJWTExpirationTime: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n\n    public async HandleGetJWTSignInProvider() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.signInProvider;\n    } catch (e) {\n      log(\"HandleGetJWTSignInProvider: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n\n     public async HandleGetJWTIssuedAtTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.issuedAtTime;\n    } catch (e) {\n      log(\"HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n\n      public async HandleGetJWTToken() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.token;\n    } catch (e) {\n      log(\"HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n}\n\nexport function AuthProvider(firebaseConfig: {}, options: RAFirebaseOptions) {\n  VerifyAuthProviderArgs(firebaseConfig, options);\n  const auth = new AuthClient(firebaseConfig, options);\n  CheckLogging(firebaseConfig, options);\n\n  return {\n    login: params => auth.HandleAuthLogin(params),\n    logout: () => auth.HandleAuthLogout(),\n    checkAuth: () => auth.HandleAuthCheck(),\n    checkError: error => auth.HandleAuthError(error),\n    getPermissions: () => auth.HandleGetPermissions(),\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\n    getJWTClaims: () => auth.HandleGetPermissions(),\n    getJWTToken: () => auth.HandleGetJWTToken()\n  };\n}\n\nfunction VerifyAuthProviderArgs(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      \"Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider\"\n    );\n  }\n}\n"],"names":["sortArray","data","field","dir","sort","a","b","aValue","bValue","rawA","rawB","Number","isFinite","toString","toLowerCase","SimpleLogger","constructor","isEnabled","localStorage","getItem","prototypeAccessors","log","this","console","bind","title","warn","error","const","logger","CheckLogging","config","options","logging","setItem","removeItem","logError","getAbsolutePath","rootRef","relativePath","Error","withSlashes","path","join","split","length","slice","_catch","body","recover","result","e","then","Symbol","iterator","asyncIterator","ResourceManager","fireWrapper","db","GetResource","resource","resources","TryGetResourcePromise","collectionQuery","_this","initPath","RefreshResource","_this2","collection","query","applyQuery","get","newDocs","list","docs","map","doc","parseFireStoreDocument","collectionPath","GetSingleDoc","docId","_this3","docSnap","exists","absolutePath","_this4","isCollectionAccessible","isAccessible","hasBeenInited","removeResource","allResources","keys","forEach","key","value","toDate","Function","Object","id","getUserLogin","Promise","resolve","reject","auth","onAuthStateChanged","user","_this6","limit","resourceName","collref","FirebaseClient","rm","apiGetList","params","filter","tryGetResource","r","filteredData","searchFields","obj","JSON","stringify","searchObjs","n","name","row","reduce","prev","curr","searchField","searchValue","searchPart","includes","doesRowMatch","filterArray","pageStart","pagination","page","perPage","apiGetOne","apiCreate","newId","parseDataAndUpload","docObj","checkRemoveIdField","addCreatedByFields","addUpdatedByFields","set","hasOverridenDocId","overridenId","_r$collection$doc$get","apiUpdate","update","catch","apiUpdateMany","_this5","all","ids","returnData","apiDelete","delete","previousData","apiDeleteMany","_this7","batch","push","commit","apiGetMany","matchDocSnaps","snap","apiGetManyReference","targetField","target","targetValue","matches","val","refresh","_this10","getCurrentUserEmail","email","getCurrentUserId","uid","docPath","fieldName","_this13","parseDataField","isArray","Array","arrayObj","index","hasOwnProperty","arrayObjFieldName","dontAddIdFieldToDoc","_this14","disableMeta","associateUsersById","currentUserIdentifier","createdate","serverTimestamp","createdby","_this15","lastupdate","updatedby","ref","fieldPath","uploadAndGetLink","rawFile","src","storagePath","saveFile","task","storage","put","res","rej","taskResult","getDownloadURL","storageError","code","fb","FirebaseWrapper","init","firebaseConfig","app","firebase","apps","initializeApp","ObtainFirebaseApp","firestore","Date","AuthClient","optionsInput","setPersistence","persistence","persistenceInput","persistenceResolved","Auth","Persistence","LOCAL","NONE","SESSION","HandleAuthLogin","username","password","signInWithEmailAndPassword","HandleAuthLogout","signOut","HandleAuthError","HandleAuthCheck","currentUser","unsubscribe","HandleGetPermissions","getIdTokenResult","token","claims","HandleGetJWTAuthTime","authTime","HandleGetJWTExpirationTime","expirationTime","HandleGetJWTSignInProvider","signInProvider","HandleGetJWTIssuedAtTime","issuedAtTime","HandleGetJWTToken","VerifyDataProviderArgs","type","GET_MANY","GET_MANY_REFERENCE","GET_LIST","GET_ONE","CREATE","UPDATE","UPDATE_MANY","DELETE","DELETE_MANY","VerifyAuthProviderArgs","login","logout","checkAuth","checkError","getPermissions","getJWTAuthTime","getJWTExpirationTime","getJWTSignInProvider","getJWTClaims","getJWTToken"],"mappings":"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"}