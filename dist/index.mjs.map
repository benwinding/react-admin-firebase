{"version":3,"file":"index.mjs","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/misc/arrayHelpers.ts","../src/misc/logger.ts","../src/misc/pathHelper.ts","../src/providers/database/ResourceManager.ts","../src/providers/database/FirebaseClient.ts","../src/providers/DataProvider.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/AuthProvider.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && !check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","function isEmptyObj(obj) {\r\n  if (!obj) {\r\n    return true;\r\n  }\r\n  return JSON.stringify(obj) === \"{}\";\r\n}\r\n\r\nexport function sortArray(\r\n  data: Array<{}>,\r\n  field: string,\r\n  dir: \"asc\" | \"desc\"\r\n): void {\r\n  data.sort((a: {}, b: {}) => {\r\n    const rawA = a[field];\r\n    const rawB = b[field];\r\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\r\n    let aValue: string, bValue: string;\r\n    if (isNumberField) {\r\n      aValue = rawA;\r\n      bValue = rawB;\r\n    } else {\r\n      aValue = (a[field] || \"\").toString().toLowerCase();\r\n      bValue = (b[field] || \"\").toString().toLowerCase();\r\n    }\r\n    if (aValue > bValue) {\r\n      return dir === \"asc\" ? 1 : -1;\r\n    }\r\n    if (aValue < bValue) {\r\n      return dir === \"asc\" ? -1 : 1;\r\n    }\r\n    return 0;\r\n  });\r\n}\r\n\r\nexport function filterArray(\r\n  data: Array<{}>,\r\n  searchFields: { [field: string]: string }\r\n): Array<{}> {\r\n  if (isEmptyObj(searchFields)) {\r\n    return data;\r\n  }\r\n  const searchObjs = Object.keys(searchFields).map(n => ({\r\n    name: n,\r\n    value: (searchFields[n] || '').toLowerCase()\r\n  }));\r\n  return data.filter(row =>\r\n    searchObjs.reduce(\r\n      (prev, curr) => doesRowMatch(row, curr.name, curr.value) && prev,\r\n      true\r\n    )\r\n  );\r\n}\r\n\r\nfunction doesRowMatch(\r\n  row: {},\r\n  searchField: string,\r\n  searchValue: string\r\n): boolean {\r\n  const searchPart = row[searchField];\r\n  if (typeof searchPart !== \"string\") {\r\n    return false;\r\n  }\r\n  return searchPart\r\n    .toString()\r\n    .toLowerCase()\r\n    .includes(searchValue.toLowerCase());\r\n}\r\n","import { RAFirebaseOptions } from \"providers/RAFirebaseOptions\";\r\n\r\n// UTILS\r\n\r\nexport class SimpleLogger {\r\n  private title = \"ðŸ”¥r-a-f: \";\r\n\r\n  isEnabled() {\r\n    return !!localStorage.getItem('LOGGING_ENABLED');\r\n  }\r\n\r\n  public get log() {\r\n    if (!this.isEnabled()) {\r\n      return (...any) => {};\r\n    }\r\n    const boundLogFn: (...any) => void = console.log.bind(console, this.title);\r\n    return boundLogFn;\r\n  }\r\n\r\n  public get warn() {\r\n    if (!this.isEnabled()) {\r\n      return (...any) => {};\r\n    }\r\n    const boundLogFn: (...any) => void = console.warn.bind(console, this.title);\r\n    return boundLogFn;\r\n  }\r\n\r\n  public get error() {\r\n    if (!this.isEnabled()) {\r\n      return (...any) => {};\r\n    }\r\n    const boundLogFn: (...any) => void = console.error.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n}\r\n\r\nconst logger = new SimpleLogger();\r\n\r\nexport function CheckLogging(config: {}, options: RAFirebaseOptions) {\r\n  const logSignalDeprecated = config && config[\"debug\"];\r\n  const logSignal = options.logging;\r\n  if (logSignalDeprecated || logSignal) {\r\n    localStorage.setItem('LOGGING_ENABLED', 'true')\r\n  } else {\r\n    localStorage.removeItem('LOGGING_ENABLED')\r\n  }\r\n}\r\n\r\nexport const log = logger.log;\r\nexport const logWarn = logger.warn;\r\nexport const logError = logger.error;\r\n","import path from 'path-browserify'\r\n\r\nexport function getAbsolutePath(rootRef: string, relativePath: string): string {\r\n  if (!rootRef) {\r\n    return relativePath;\r\n  }\r\n  if (!relativePath) {\r\n    throw new Error('Resource name must be a string of length greater than 0 characters');\r\n  }\r\n  const withSlashes = path.join('/', rootRef, '/', relativePath, '/');\r\n  const slashCount = withSlashes.split(\"/\").length - 1\r\n  if (slashCount % 2) {\r\n    throw new Error(`The rootRef path must point to a \"document\" not a \"collection\"\r\ne.g. /collection/document/ or /collection/document/collection/document/`);\r\n  }\r\n  const withOutSlashes = withSlashes.slice(1, -1);\r\n  return withOutSlashes;\r\n}\r\n\r\nexport function joinPaths(path1, path2) {\r\n  return path.join(path1, path2);\r\n}","// Firebase types\r\nimport {\r\n  CollectionReference,\r\n  QueryDocumentSnapshot,\r\n  FirebaseFirestore\r\n} from \"@firebase/firestore-types\";\r\nimport { RAFirebaseOptions } from \"../RAFirebaseOptions\";\r\nimport { IFirebaseWrapper } from \"./firebase/IFirebaseWrapper\";\r\nimport { User } from \"@firebase/auth-types\";\r\nimport { log, getAbsolutePath, messageTypes, logError } from \"../../misc\";\r\n\r\nexport interface IResource {\r\n  path: string;\r\n  pathAbsolute: string;\r\n  collection: CollectionReference;\r\n  list: Array<{}>;\r\n}\r\n\r\nexport class ResourceManager {\r\n  private resources: {\r\n    [resourceName: string]: IResource;\r\n  } = {};\r\n\r\n  private db: FirebaseFirestore;\r\n\r\n  constructor(\r\n    private fireWrapper: IFirebaseWrapper,\r\n    private options: RAFirebaseOptions\r\n  ) {\r\n    this.db = fireWrapper.db();\r\n  }\r\n\r\n  public GetResource(relativePath: string): IResource {\r\n    const resource: IResource = this.resources[relativePath];\r\n    if (!resource) {\r\n      throw new Error(\r\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\r\n      );\r\n    }\r\n    return resource;\r\n  }\r\n\r\n  public async TryGetResourcePromise(\r\n    relativePath: string,\r\n    collectionQuery: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    log(\"resourceManager.TryGetResourcePromise\", {\r\n      relativePath,\r\n      collectionQuery\r\n    });\r\n    await this.initPath(relativePath, collectionQuery);\r\n\r\n    const resource: IResource = this.resources[relativePath];\r\n    if (!resource) {\r\n      throw new Error(\r\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\r\n      );\r\n    }\r\n    return resource;\r\n  }\r\n\r\n  public async RefreshResource(\r\n    relativePath: string,\r\n    collectionQuery: messageTypes.CollectionQueryType\r\n  ) {\r\n    log(\"resourceManager.RefreshResource\", { relativePath, collectionQuery });\r\n    await this.initPath(relativePath, collectionQuery);\r\n    const resource = this.resources[relativePath];\r\n\r\n    const collection = resource.collection;\r\n    const query = this.applyQuery(collection, collectionQuery);\r\n    const newDocs = await query.get();\r\n\r\n    resource.list = newDocs.docs.map(doc => this.parseFireStoreDocument(doc));\r\n    log(\"resourceManager.RefreshResource\", {\r\n      newDocs,\r\n      resource,\r\n      collectionPath: collection.path\r\n    });\r\n  }\r\n\r\n  public async GetSingleDoc(relativePath: string, docId: string) {\r\n    await this.initPath(relativePath);\r\n    const resource = this.resources[relativePath];\r\n    const docSnap = await resource.collection.doc(docId).get();\r\n    if (!docSnap.exists) {\r\n      throw new Error(\"react-admin-firebase: No id found matching: \" + docId);\r\n    }\r\n    const result = this.parseFireStoreDocument(docSnap);\r\n    log(\"resourceManager.GetSingleDoc\", {\r\n      relativePath,\r\n      resource,\r\n      docId,\r\n      docSnap,\r\n      result\r\n    });\r\n    return result;\r\n  }\r\n\r\n  private async initPath(\r\n    relativePath: string,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<void> {\r\n    const absolutePath = getAbsolutePath(this.options.rootRef, relativePath);\r\n    const isAccessible = await this.isCollectionAccessible(\r\n      absolutePath,\r\n      collectionQuery\r\n    );\r\n\r\n    const hasBeenInited = !!this.resources[relativePath];\r\n    log(\"resourceManager.initPath()\", {\r\n      absolutePath,\r\n      isAccessible,\r\n      hasBeenInited\r\n    });\r\n    if (!isAccessible && hasBeenInited) {\r\n      log(\"resourceManager.initPath() not accessible, removing resource...\");\r\n      this.removeResource(relativePath);\r\n      return;\r\n    }\r\n    if (hasBeenInited) {\r\n      log(\"resourceManager.initPath() has been initialized already...\");\r\n      return;\r\n    }\r\n    const collection = this.db.collection(absolutePath);\r\n    const list: Array<{}> = [];\r\n    const resource: IResource = {\r\n      collection: collection,\r\n      list: list,\r\n      path: relativePath,\r\n      pathAbsolute: absolutePath\r\n    };\r\n    this.resources[relativePath] = resource;\r\n    log(\"resourceManager.initPath() setting resource...\", {\r\n      resource,\r\n      allResources: this.resources,\r\n      collection: collection,\r\n      collectionPath: collection.path\r\n    });\r\n  }\r\n\r\n  private parseFireStoreDocument(doc: QueryDocumentSnapshot): {} {\r\n    const data = doc.data();\r\n    Object.keys(data).forEach(key => {\r\n      const value = data[key];\r\n      if (value && value.toDate && value.toDate instanceof Function) {\r\n        data[key] = value.toDate();\r\n      }\r\n    });\r\n    // React Admin requires an id field on every document,\r\n    // So we can just using the firestore document id\r\n    return { id: doc.id, ...data };\r\n  }\r\n\r\n  public async getUserLogin(): Promise<User> {\r\n    return new Promise((resolve, reject) => {\r\n      this.fireWrapper.auth().onAuthStateChanged(user => {\r\n        resolve(user);\r\n      });\r\n    });\r\n  }\r\n\r\n  private async isCollectionAccessible(\r\n    absolutePath: string,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<boolean> {\r\n    try {\r\n      const collection = this.db.collection(absolutePath);\r\n      const query = this.applyQuery(collection, collectionQuery);\r\n\r\n      await query.limit(1).get();\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private removeResource(resourceName: string) {\r\n    delete this.resources[resourceName];\r\n  }\r\n\r\n  private applyQuery(\r\n    collection: CollectionReference,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): CollectionReference {\r\n    let collref: CollectionReference;\r\n    if (collectionQuery) {\r\n      collref = collectionQuery(collection);\r\n    } else {\r\n      collref = collection;\r\n    }\r\n    log(\"resourceManager.applyQuery() ...\", {\r\n      collection,\r\n      collectionQuery: (collectionQuery || \"-\").toString(),\r\n      collref\r\n    });\r\n    return collref;\r\n  }\r\n}\r\n","import { FirebaseFirestore } from \"@firebase/firestore-types\";\r\nimport { ResourceManager, IResource } from \"./ResourceManager\";\r\nimport { RAFirebaseOptions } from \"../RAFirebaseOptions\";\r\nimport { IFirebaseWrapper } from \"./firebase/IFirebaseWrapper\";\r\nimport { IFirebaseClient } from \"./IFirebaseClient\";\r\nimport {\r\n  filterArray,\r\n  joinPaths,\r\n  log,\r\n  logError,\r\n  messageTypes,\r\n  sortArray\r\n} from \"../../misc\";\r\n\r\nexport class FirebaseClient implements IFirebaseClient {\r\n  private db: FirebaseFirestore;\r\n  private rm: ResourceManager;\r\n\r\n  constructor(\r\n    private fireWrapper: IFirebaseWrapper,\r\n    private options: RAFirebaseOptions\r\n  ) {\r\n    this.db = fireWrapper.db();\r\n    this.rm = new ResourceManager(this.fireWrapper, this.options);\r\n  }\r\n  public async apiGetList(\r\n    resourceName: string,\r\n    params: messageTypes.IParamsGetList\r\n  ): Promise<messageTypes.IResponseGetList> {\r\n    log(\"apiGetList\", { resourceName, params });\r\n\r\n    const collectionQuery = params.filter.collectionQuery;\r\n    delete params.filter.collectionQuery;\r\n\r\n    const r = await this.tryGetResource(\r\n      resourceName,\r\n      \"REFRESH\",\r\n      collectionQuery\r\n    );\r\n    const data = r.list;\r\n    if (params.sort != null) {\r\n      const { field, order } = params.sort;\r\n      if (order === \"ASC\") {\r\n        sortArray(data, field, \"asc\");\r\n      } else {\r\n        sortArray(data, field, \"desc\");\r\n      }\r\n    }\r\n    // @ts-ignore\r\n    const filteredData = filterArray(data, params.filter);\r\n    const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\r\n    const pageEnd = pageStart + params.pagination.perPage;\r\n    const dataPage = filteredData.slice(pageStart, pageEnd);\r\n    const total = filteredData.length;\r\n    return {\r\n      data: dataPage,\r\n      total\r\n    };\r\n  }\r\n  public async apiGetOne(\r\n    resourceName: string,\r\n    params: messageTypes.IParamsGetOne\r\n  ): Promise<messageTypes.IResponseGetOne> {\r\n    log(\"apiGetOne\", { resourceName, params });\r\n    try {\r\n      const data = await this.rm.GetSingleDoc(resourceName, params.id);\r\n      return { data: data };\r\n    } catch (error) {\r\n      throw new Error(\r\n        \"Error getting id: \" + params.id + \" from collection: \" + resourceName\r\n      );\r\n    }\r\n  }\r\n  public async apiCreate(\r\n    resourceName: string,\r\n    params: messageTypes.IParamsCreate\r\n  ): Promise<messageTypes.IResponseCreate> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    log(\"apiCreate\", { resourceName, resource: r, params });\r\n    const hasOverridenDocId = params.data && params.data.id;\r\n    log(\"apiCreate\", { hasOverridenDocId });\r\n    if (hasOverridenDocId) {\r\n      const overridenId = params.data.id;\r\n      const exists = (await r.collection.doc(overridenId).get()).exists;\r\n      if (exists) {\r\n        throw new Error(\r\n          `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\r\n        );\r\n      }\r\n      const data = await this.parseDataAndUpload(r, overridenId, params.data);\r\n      if (!overridenId) {\r\n        throw new Error(\"id must be a valid string\");\r\n      }\r\n      const docObj = { ...data };\r\n      this.checkRemoveIdField(docObj);\r\n      await this.addCreatedByFields(docObj);\r\n      await this.addUpdatedByFields(docObj);\r\n      log(\"apiCreate\", { docObj });\r\n      await r.collection.doc(overridenId).set(docObj, { merge: false });\r\n      return {\r\n        data: {\r\n          ...data,\r\n          id: overridenId\r\n        }\r\n      };\r\n    }\r\n    const newId = this.db.collection(\"collections\").doc().id;\r\n    const data = await this.parseDataAndUpload(r, newId, params.data);\r\n    const docObj = { ...data };\r\n    this.checkRemoveIdField(docObj);\r\n    await this.addCreatedByFields(docObj);\r\n    await this.addUpdatedByFields(docObj);\r\n    await r.collection.doc(newId).set(docObj, { merge: false });\r\n    return {\r\n      data: {\r\n        ...data,\r\n        id: newId\r\n      }\r\n    };\r\n  }\r\n  public async apiUpdate(\r\n    resourceName: string,\r\n    params: messageTypes.IParamsUpdate\r\n  ): Promise<messageTypes.IResponseUpdate> {\r\n    const id = params.id;\r\n    delete params.data.id;\r\n    const r = await this.tryGetResource(resourceName);\r\n    log(\"apiUpdate\", { resourceName, resource: r, params });\r\n    const data = await this.parseDataAndUpload(r, id, params.data);\r\n    const docObj = { ...data };\r\n    this.checkRemoveIdField(docObj);\r\n    await this.addUpdatedByFields(docObj);\r\n    r.collection\r\n      .doc(id)\r\n      .update(docObj)\r\n      .catch(error => {\r\n        logError(\"apiUpdate error\", { error });\r\n      });\r\n    return {\r\n      data: {\r\n        ...data,\r\n        id: id\r\n      }\r\n    };\r\n  }\r\n  public async apiUpdateMany(\r\n    resourceName: string,\r\n    params: messageTypes.IParamsUpdateMany\r\n  ): Promise<messageTypes.IResponseUpdateMany> {\r\n    delete params.data.id;\r\n    const r = await this.tryGetResource(resourceName);\r\n    log(\"apiUpdateMany\", { resourceName, resource: r, params });\r\n    const ids = params.ids;\r\n    const returnData = await Promise.all(\r\n      ids.map(async id => {\r\n        const data = await this.parseDataAndUpload(r, id, params.data);\r\n        const docObj = { ...data };\r\n        this.checkRemoveIdField(docObj);\r\n        await this.addUpdatedByFields(docObj);\r\n        r.collection\r\n          .doc(id)\r\n          .update(docObj)\r\n          .catch(error => {\r\n            logError(\"apiUpdateMany error\", { error });\r\n          });\r\n        return {\r\n          ...data,\r\n          id: id\r\n        };\r\n      })\r\n    );\r\n    return {\r\n      data: returnData\r\n    };\r\n  }\r\n  public async apiDelete(\r\n    resourceName: string,\r\n    params: messageTypes.IParamsDelete\r\n  ): Promise<messageTypes.IResponseDelete> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    log(\"apiDelete\", { resourceName, resource: r, params });\r\n    r.collection\r\n      .doc(params.id)\r\n      .delete()\r\n      .catch(error => {\r\n        logError(\"apiDelete error\", { error });\r\n      });\r\n    return {\r\n      data: params.previousData\r\n    };\r\n  }\r\n  public async apiDeleteMany(\r\n    resourceName: string,\r\n    params: messageTypes.IParamsDeleteMany\r\n  ): Promise<messageTypes.IResponseDeleteMany> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    log(\"apiDeleteMany\", { resourceName, resource: r, params });\r\n    const returnData: { id: string }[] = [];\r\n    const batch = this.db.batch();\r\n    for (const id of params.ids) {\r\n      batch.delete(r.collection.doc(id));\r\n      returnData.push({ id });\r\n    }\r\n    batch.commit().catch(error => {\r\n      logError(\"apiDeleteMany error\", { error });\r\n    });\r\n    return { data: returnData };\r\n  }\r\n  public async apiGetMany(\r\n    resourceName: string,\r\n    params: messageTypes.IParamsGetMany\r\n  ): Promise<messageTypes.IResponseGetMany> {\r\n    const r = await this.tryGetResource(resourceName, \"REFRESH\");\r\n    log(\"apiGetMany\", { resourceName, resource: r, params });\r\n    const ids = params.ids;\r\n    const matchDocSnaps = await Promise.all(\r\n      ids.map(id => r.collection.doc(id).get())\r\n    );\r\n    const matches = matchDocSnaps.map(snap => {\r\n      return { ...snap.data(), id: snap.id };\r\n    });\r\n    return {\r\n      data: matches\r\n    };\r\n  }\r\n  public async apiGetManyReference(\r\n    resourceName: string,\r\n    params: messageTypes.IParamsGetManyReference\r\n  ): Promise<messageTypes.IResponseGetManyReference> {\r\n    const r = await this.tryGetResource(resourceName, \"REFRESH\");\r\n    log(\"apiGetManyReference\", { resourceName, resource: r, params });\r\n    const data = r.list;\r\n    const targetField = params.target;\r\n    const targetValue = params.id;\r\n    const matches = data.filter(val => val[targetField] === targetValue);\r\n    if (params.sort != null) {\r\n      const { field, order } = params.sort;\r\n      if (order === \"ASC\") {\r\n        sortArray(matches, field, \"asc\");\r\n      } else {\r\n        sortArray(matches, field, \"desc\");\r\n      }\r\n    }\r\n    const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\r\n    const pageEnd = pageStart + params.pagination.perPage;\r\n    const dataPage = matches.slice(pageStart, pageEnd);\r\n    const total = matches.length;\r\n    return { data: dataPage, total };\r\n  }\r\n  private async tryGetResource(\r\n    resourceName: string,\r\n    refresh?: \"REFRESH\",\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    if (refresh) {\r\n      await this.rm.RefreshResource(resourceName, collectionQuery);\r\n    }\r\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\r\n  }\r\n  private async getCurrentUserEmail() {\r\n    const user = await this.rm.getUserLogin();\r\n    if (user) {\r\n      return user.email;\r\n    } else {\r\n      return \"annonymous user\";\r\n    }\r\n  }\r\n\r\n  private async parseDataAndUpload(r: IResource, id: string, data: any) {\r\n    if (!data) {\r\n      return data;\r\n    }\r\n    const docPath = r.collection.doc(id).path;\r\n\r\n    await Promise.all(\r\n      Object.keys(data).map(async fieldName => {\r\n        const val = data[fieldName];\r\n        const isArray = Array.isArray(val);\r\n        if (isArray) {\r\n          await Promise.all(\r\n            (val as []).map((arrayObj, index) => {\r\n              if (!!val[index] && val[index].hasOwnProperty(\"rawFile\")) {\r\n                return Promise.all([\r\n                  this.parseDataField(val[index], docPath, fieldName + index)\r\n                ]);\r\n              } else {\r\n                return Promise.all(\r\n                  Object.keys(arrayObj).map(arrayObjFieldName => {\r\n                    const arrayObjVal = arrayObj[arrayObjFieldName];\r\n                    return this.parseDataField(\r\n                      arrayObjVal,\r\n                      docPath,\r\n                      fieldName + arrayObjFieldName + index\r\n                    );\r\n                  })\r\n                );\r\n              }\r\n            })\r\n          );\r\n        }\r\n        await this.parseDataField(val, docPath, fieldName);\r\n      })\r\n    );\r\n    return data;\r\n  }\r\n\r\n  private checkRemoveIdField(obj: any) {\r\n    if (this.options.dontAddIdFieldToDoc) {\r\n      delete obj.id\r\n    }\r\n  }\r\n\r\n  private async addCreatedByFields(obj: any) {\r\n    if (this.options.disableMeta) {\r\n      return;\r\n    }\r\n    const currentUserEmail = await this.getCurrentUserEmail();\r\n    obj.createdate = this.fireWrapper.serverTimestamp();\r\n    obj.createdby = currentUserEmail;\r\n  }\r\n\r\n  private async addUpdatedByFields(obj: any) {\r\n    if (this.options.disableMeta) {\r\n      return;\r\n    }\r\n    const currentUserEmail = await this.getCurrentUserEmail();\r\n    obj.lastupdate = this.fireWrapper.serverTimestamp();\r\n    obj.updatedby = currentUserEmail;\r\n  }\r\n\r\n  private async parseDataField(ref: any, docPath: string, fieldPath: string) {\r\n    const hasRawFile = !!ref && ref.hasOwnProperty(\"rawFile\");\r\n    if (!hasRawFile) {\r\n      return;\r\n    }\r\n    ref.src = await this.uploadAndGetLink(ref.rawFile, docPath, fieldPath);\r\n    delete ref.rawFile;\r\n  }\r\n\r\n  private async uploadAndGetLink(\r\n    rawFile: any,\r\n    docPath: string,\r\n    fieldPath: string\r\n  ): Promise<string> {\r\n    const storagePath = joinPaths(docPath, fieldPath);\r\n    const storageLink = await this.saveFile(storagePath, rawFile);\r\n    return storageLink;\r\n  }\r\n\r\n  private async saveFile(storagePath: string, rawFile: any): Promise<string> {\r\n    log(\"saveFile() saving file...\", { storagePath, rawFile });\r\n    const task = this.fireWrapper\r\n      .storage()\r\n      .ref(storagePath)\r\n      .put(rawFile);\r\n    try {\r\n      const taskResult: firebase.storage.UploadTaskSnapshot = await new Promise(\r\n        (res, rej) => task.then(res).catch(rej)\r\n      );\r\n      const getDownloadURL = await taskResult.ref.getDownloadURL();\r\n      log(\"saveFile() saved file\", {\r\n        storagePath,\r\n        taskResult,\r\n        getDownloadURL\r\n      });\r\n      return getDownloadURL;\r\n    } catch (storageError) {\r\n      if (storageError.code === \"storage/unknown\") {\r\n        logError(\r\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\r\n          { storageError }\r\n        );\r\n      } else {\r\n        logError(\"saveFile() error saving file\", {\r\n          storageError\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","import {\r\n  CREATE,\r\n  DELETE,\r\n  DELETE_MANY,\r\n  GET_LIST,\r\n  GET_MANY,\r\n  GET_MANY_REFERENCE,\r\n  GET_ONE,\r\n  UPDATE,\r\n  UPDATE_MANY,\r\n} from \"react-admin\";\r\nimport { getAbsolutePath, log, CheckLogging, messageTypes } from \"../misc\";\r\nimport { RAFirebaseOptions } from \"./RAFirebaseOptions\";\r\nimport { FirebaseClient } from \"./database/FirebaseClient\";\r\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\r\n\r\nimport { HttpError } from \"react-admin\";\r\n\r\nexport let fb: FirebaseClient;\r\n\r\nexport function DataProvider(\r\n  firebaseConfig: {},\r\n  optionsInput?: RAFirebaseOptions\r\n) {\r\n  const options = optionsInput || {};\r\n  VerifyDataProviderArgs(firebaseConfig, options);\r\n  CheckLogging(firebaseConfig, options);\r\n\r\n  log(\"react-admin-firebase:: Creating FirebaseDataProvider\", {\r\n    firebaseConfig,\r\n    options,\r\n  });\r\n  const fireWrapper = new FirebaseWrapper();\r\n  fireWrapper.init(firebaseConfig, optionsInput);\r\n  fb = new FirebaseClient(fireWrapper, options);\r\n  async function providerApi(\r\n    type: string,\r\n    resourceName: string,\r\n    params: any\r\n  ): Promise<messageTypes.IResponseAny> {\r\n    log(\"FirebaseDataProvider: event\", { type, resourceName, params });\r\n    let res: messageTypes.IResponseAny;\r\n    try {\r\n      switch (type) {\r\n        case GET_MANY:\r\n          res = await fb.apiGetMany(resourceName, params);\r\n          break;\r\n        case GET_MANY_REFERENCE:\r\n          res = await fb.apiGetManyReference(resourceName, params);\r\n          break;\r\n        case GET_LIST:\r\n          res = await fb.apiGetList(resourceName, params);\r\n          break;\r\n        case GET_ONE:\r\n          res = await fb.apiGetOne(resourceName, params);\r\n          break;\r\n        case CREATE:\r\n          res = await fb.apiCreate(resourceName, params);\r\n          break;\r\n        case UPDATE:\r\n          res = await fb.apiUpdate(resourceName, params);\r\n          break;\r\n        case UPDATE_MANY:\r\n          res = await fb.apiUpdateMany(resourceName, params);\r\n          break;\r\n        case DELETE:\r\n          res = await fb.apiDelete(resourceName, params);\r\n          break;\r\n        case DELETE_MANY:\r\n          res = await fb.apiDeleteMany(resourceName, params);\r\n          break;\r\n        default:\r\n          throw new Error(`Unknkown dataprovider command type: \"${type}\"`);\r\n      }\r\n      return res;\r\n    } catch (error) {\r\n      // TODO: Determine if Auth Error\r\n      throw { status: 409, message: error.toString(), json: res };\r\n    }\r\n  }\r\n  return providerApi;\r\n}\r\n\r\nfunction VerifyDataProviderArgs(\r\n  firebaseConfig: {},\r\n  options?: RAFirebaseOptions\r\n) {\r\n  const hasNoApp = !options || !options.app;\r\n  const hasNoConfig = !firebaseConfig;\r\n  if (hasNoConfig && hasNoApp) {\r\n    throw new Error(\r\n      \"Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider\"\r\n    );\r\n  }\r\n  if (options.rootRef) {\r\n    // Will throw error if rootRef doesn't point to a document\r\n    getAbsolutePath(options.rootRef, \"test\");\r\n  }\r\n}\r\n","import { IFirebaseWrapper } from \"./IFirebaseWrapper\";\r\nimport { RAFirebaseOptions } from \"providers/RAFirebaseOptions\";\r\n\r\nimport firebase from \"firebase/app\";\r\nimport \"firebase/firestore\";\r\nimport \"firebase/auth\";\r\nimport \"firebase/storage\";\r\n\r\nexport class FirebaseWrapper implements IFirebaseWrapper {\r\n  private firestore: firebase.firestore.Firestore;\r\n  private app: firebase.app.App;\r\n\r\n  constructor() { }\r\n\r\n  public init(firebaseConfig: {}, options: RAFirebaseOptions): void {\r\n    this.app = ObtainFirebaseApp(firebaseConfig, options);\r\n    this.firestore = this.app.firestore();\r\n  }\r\n  public db(): firebase.firestore.Firestore {\r\n    return this.firestore;\r\n  }\r\n  public serverTimestamp() {\r\n    // This line doesn't work for some reason, might be firebase sdk.\r\n    // return firebase.firestore.FieldValue.serverTimestamp();\r\n    return new Date();\r\n  }\r\n  public auth() {\r\n    return this.app.auth() as any;\r\n  }\r\n  public storage() {\r\n    return this.app.storage();\r\n  }\r\n}\r\n\r\nfunction ObtainFirebaseApp(firebaseConfig: {}, options: RAFirebaseOptions): firebase.app.App {\r\n  if (options.app) {\r\n    return options.app;\r\n  }\r\n  const isInitialized = !!firebase.apps.length;\r\n  if (isInitialized) {\r\n    const app = firebase.app();\r\n    return app;\r\n  } else {\r\n    const app = firebase.initializeApp(firebaseConfig);\r\n    return app;\r\n  }\r\n}","import { messageTypes } from './../misc/messageTypes';\r\nimport firebase from \"firebase/app\";\r\nimport \"firebase/auth\";\r\nimport { FirebaseAuth } from \"@firebase/auth-types\";\r\nimport { log, CheckLogging } from \"../misc\";\r\nimport { RAFirebaseOptions } from \"./RAFirebaseOptions\";\r\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\r\n\r\nclass AuthClient {\r\n  private auth: FirebaseAuth;\r\n\r\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\r\n    const options = optionsInput || {};\r\n    log(\"Auth Client: initializing...\", { firebaseConfig, options });\r\n    const fireWrapper = new FirebaseWrapper();\r\n    fireWrapper.init(firebaseConfig, options);\r\n    this.auth = fireWrapper.auth();\r\n    this.setPersistence(options.persistence);\r\n  }\r\n\r\n  setPersistence(persistenceInput: \"session\" | \"local\" | \"none\") {\r\n    let persistenceResolved: string;\r\n    switch (persistenceInput) {\r\n      case \"local\":\r\n        persistenceResolved = firebase.auth.Auth.Persistence.LOCAL;\r\n        break;\r\n      case \"none\":\r\n        persistenceResolved = firebase.auth.Auth.Persistence.NONE;\r\n        break;\r\n      case \"session\":\r\n      default:\r\n        persistenceResolved = firebase.auth.Auth.Persistence.SESSION;\r\n        break;\r\n    }\r\n    log(\"setPersistence\", { persistenceInput, persistenceResolved });\r\n    this.auth\r\n      .setPersistence(persistenceResolved)\r\n      .catch(error => console.error(error));\r\n  }\r\n\r\n  public async HandleAuthLogin(params) {\r\n    const { username, password } = params;\r\n\r\n    if (username && password) {\r\n      try {\r\n        const user = await this.auth.signInWithEmailAndPassword(\r\n          username,\r\n          password\r\n        );\r\n        log(\"HandleAuthLogin: user sucessfully logged in\", { user });\r\n        return user;\r\n      } catch (e) {\r\n        log(\"HandleAuthLogin: invalid credentials\", { params });\r\n        throw new Error(\"Login error: invalid credentials\");\r\n      }\r\n    } else {\r\n      return this.getUserLogin();\r\n    }\r\n  }\r\n\r\n  public HandleAuthLogout() {\r\n    return this.auth.signOut();\r\n  }\r\n\r\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\r\n    log(\"HandleAuthLogin: invalid credentials\", { errorHttp });\r\n    const status = !!errorHttp && errorHttp.status;\r\n    if (status === 409 || status === 200) {\r\n      return Promise.resolve(\"API is authenticated\");\r\n    }\r\n    return Promise.reject(\"Recieved authentication error from API\");\r\n  }\r\n\r\n  public HandleAuthCheck() {\r\n    return this.getUserLogin();\r\n  }\r\n\r\n  public getUserLogin() {\r\n    return new Promise((resolve, reject) => {\r\n      if (this.auth.currentUser) return resolve(this.auth.currentUser);\r\n      const unsubscribe = this.auth.onAuthStateChanged(user => {\r\n        unsubscribe();\r\n        if (user) {\r\n          resolve(user);\r\n        } else {\r\n          reject();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  public async HandleGetPermissions() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.claims;\r\n    } catch (e) {\r\n      log(\"HandleGetPermission: no user is logged in or tokenResult error\", {\r\n        e\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTAuthTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.authTime;\r\n    } catch (e) {\r\n      log(\"HandleGetJWTAuthTime: no user is logged in or tokenResult error\", {\r\n        e\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTExpirationTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.expirationTime;\r\n    } catch (e) {\r\n      log(\"HandleGetJWTExpirationTime: no user is logged in or tokenResult error\", {\r\n        e\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n    public async HandleGetJWTSignInProvider() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.signInProvider;\r\n    } catch (e) {\r\n      log(\"HandleGetJWTSignInProvider: no user is logged in or tokenResult error\", {\r\n        e\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n     public async HandleGetJWTIssuedAtTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.issuedAtTime;\r\n    } catch (e) {\r\n      log(\"HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error\", {\r\n        e\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n      public async HandleGetJWTToken() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.token;\r\n    } catch (e) {\r\n      log(\"HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error\", {\r\n        e\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport function AuthProvider(firebaseConfig: {}, options: RAFirebaseOptions) {\r\n  VerifyAuthProviderArgs(firebaseConfig, options);\r\n  const auth = new AuthClient(firebaseConfig, options);\r\n  CheckLogging(firebaseConfig, options);\r\n\r\n  return {\r\n    login: params => auth.HandleAuthLogin(params),\r\n    logout: () => auth.HandleAuthLogout(),\r\n    checkAuth: () => auth.HandleAuthCheck(),\r\n    checkError: error => auth.HandleAuthError(error),\r\n    getPermissions: () => auth.HandleGetPermissions(),\r\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\r\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\r\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\r\n    getJWTClaims: () => auth.HandleGetPermissions(),\r\n    getJWTToken: () => auth.HandleGetJWTToken()\r\n  };\r\n}\r\n\r\nfunction VerifyAuthProviderArgs(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n) {\r\n  const hasNoApp = !options || !options.app;\r\n  const hasNoConfig = !firebaseConfig;\r\n  if (hasNoConfig && hasNoApp) {\r\n    throw new Error(\r\n      \"Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider\"\r\n    );\r\n  }\r\n}\r\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_catch","body","recover","sortArray","data","field","dir","sort","a","b","aValue","bValue","rawA","rawB","Number","isFinite","toString","toLowerCase","Symbol","iterator","asyncIterator","SimpleLogger","constructor","isEnabled","localStorage","getItem","prototypeAccessors","log","console","title","warn","error","const","logger","CheckLogging","config","options","logging","setItem","removeItem","logError","getAbsolutePath","rootRef","relativePath","Error","withSlashes","path","join","split","length","slice","ResourceManager","fireWrapper","db","GetResource","resource","resources","TryGetResourcePromise","collectionQuery","initPath","RefreshResource","_this2","collection","query","applyQuery","get","newDocs","list","docs","map","doc","parseFireStoreDocument","collectionPath","GetSingleDoc","docId","_this3","docSnap","exists","absolutePath","_this4","isCollectionAccessible","isAccessible","hasBeenInited","removeResource","allResources","keys","forEach","key","toDate","Function","Object","id","getUserLogin","Promise","resolve","reject","auth","onAuthStateChanged","user","_this6","limit","resourceName","collref","FirebaseClient","rm","apiGetList","params","filter","tryGetResource","r","filteredData","searchFields","obj","JSON","stringify","searchObjs","n","name","row","reduce","prev","curr","searchField","searchValue","searchPart","includes","doesRowMatch","filterArray","pageStart","pagination","page","perPage","apiGetOne","apiCreate","newId","parseDataAndUpload","docObj","checkRemoveIdField","addCreatedByFields","addUpdatedByFields","set","hasOverridenDocId","overridenId","_r$collection$doc$get","apiUpdate","update","catch","apiUpdateMany","_this5","all","ids","returnData","apiDelete","delete","previousData","apiDeleteMany","_this7","batch","push","commit","apiGetMany","matchDocSnaps","snap","apiGetManyReference","targetField","target","targetValue","matches","val","refresh","_this10","getCurrentUserEmail","email","docPath","fieldName","_this12","parseDataField","isArray","Array","arrayObj","index","hasOwnProperty","arrayObjFieldName","dontAddIdFieldToDoc","_this13","disableMeta","currentUserEmail","createdate","serverTimestamp","createdby","_this14","lastupdate","updatedby","ref","fieldPath","uploadAndGetLink","rawFile","src","storagePath","saveFile","task","storage","put","res","rej","taskResult","getDownloadURL","storageError","code","fb","FirebaseWrapper","DataProvider","firebaseConfig","optionsInput","app","VerifyDataProviderArgs","init","type","discriminant","cases","awaitBody","dispatchIndex","outer","i","test","testValue","fallthroughCheck","_resumeAfterBody","_resumeAfterTest","GET_MANY","GET_MANY_REFERENCE","GET_LIST","GET_ONE","CREATE","UPDATE","UPDATE_MANY","DELETE","DELETE_MANY","status","message","json","firebase","apps","initializeApp","ObtainFirebaseApp","firestore","Date","AuthClient","setPersistence","persistence","AuthProvider","VerifyAuthProviderArgs","login","HandleAuthLogin","logout","HandleAuthLogout","checkAuth","HandleAuthCheck","checkError","HandleAuthError","getPermissions","HandleGetPermissions","getJWTAuthTime","HandleGetJWTAuthTime","getJWTExpirationTime","HandleGetJWTExpirationTime","getJWTSignInProvider","HandleGetJWTSignInProvider","getJWTClaims","getJWTToken","HandleGetJWTToken","persistenceInput","persistenceResolved","Auth","Persistence","LOCAL","NONE","SESSION","username","password","signInWithEmailAndPassword","signOut","errorHttp","currentUser","unsubscribe","getIdTokenResult","token","claims","authTime","expirationTime","signInProvider","HandleGetJWTIssuedAtTime","issuedAtTime"],"mappings":"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"}